{"/home/travis/build/npmtest/node-npmtest-fv/test.js":"/* istanbul instrument in package npmtest_fv */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-fv/lib.npmtest_fv.js":"/* istanbul instrument in package npmtest_fv */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_fv = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_fv = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-fv/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-fv && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_fv */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_fv\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_fv.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_fv.rollup.js'] =\n            local.assetsDict['/assets.npmtest_fv.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_fv.__dirname + '/lib.npmtest_fv.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-fv/node_modules/fv/lib/index.js":"// Generated by CoffeeScript 1.10.0\nmodule.exports.FormReader = require('./form_reader');\n\nmodule.exports.estimateTransform = require('./estimate_transform').estimateTransform;\n\nmodule.exports.filters = {};\n\nmodule.exports.filters.binarize = require('./filters/binarize');\n\nmodule.exports.filters.darkenInk = require('./filters/darken_ink');\n\nmodule.exports.filters.deskew = require('./filters/deskew');\n\nmodule.exports.filters.filterBackground = require('./filters/filter_background');\n\nmodule.exports.filters.removeRed = require('./filters/remove_red');\n","/home/travis/build/npmtest/node-npmtest-fv/node_modules/fv/lib/form_reader.js":"// Generated by CoffeeScript 1.10.0\nvar Form, FormReader, async, distinctColor, dv, estimateTransform, findBarcodes, findCheckboxes, findText, matchBarcodes, matchByPath, matchCheckboxes, matchText, unpack,\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\ndv = require('dv');\n\nasync = require('async');\n\nfindBarcodes = require('./find_barcodes').findBarcodes;\n\nfindCheckboxes = require('./find_checkboxes').findCheckboxes;\n\nfindText = require('./find_text').findText;\n\nestimateTransform = require('./estimate_transform').estimateTransform;\n\nmatchBarcodes = require('./match_barcodes').matchBarcodes;\n\nmatchText = require('./match_text').matchText;\n\nmatchCheckboxes = require('./match_checkboxes').matchCheckboxes;\n\nunpack = require('./schema').unpack;\n\nmatchByPath = function(field, formData) {\n  var i, item, len, ref, tail;\n  if (!(((field != null ? field.box : void 0) != null) && ((field != null ? field.path : void 0) != null))) {\n    return;\n  }\n  tail = formData;\n  ref = field.path.split('.');\n  for (i = 0, len = ref.length; i < len; i++) {\n    item = ref[i];\n    tail = tail[item];\n    if (tail == null) {\n      return;\n    }\n  }\n  if ((tail != null ? tail.box : void 0) != null) {\n    return tail;\n  }\n};\n\ndistinctColor = function(index) {\n  var color, colors;\n  colors = [\"#000000\", \"#FFFF00\", \"#1CE6FF\", \"#FF34FF\", \"#FF4A46\", \"#008941\", \"#006FA6\", \"#A30059\", \"#FFDBE5\", \"#7A4900\", \"#0000A6\", \"#63FFAC\", \"#B79762\", \"#004D43\", \"#8FB0FF\", \"#997D87\", \"#5A0007\", \"#809693\", \"#FEFFE6\", \"#1B4400\", \"#4FC601\", \"#3B5DFF\", \"#4A3B53\", \"#FF2F80\", \"#61615A\", \"#BA0900\", \"#6B7900\", \"#00C2A0\", \"#FFAA92\", \"#FF90C9\", \"#B903AA\", \"#D16100\", \"#DDEFFF\", \"#000035\", \"#7B4F4B\", \"#A1C299\", \"#300018\", \"#0AA6D8\", \"#013349\", \"#00846F\", \"#372101\", \"#FFB500\", \"#C2FFED\", \"#A079BF\", \"#CC0744\", \"#C0B9B2\", \"#C2FF99\", \"#001E09\", \"#00489C\", \"#6F0062\", \"#0CBD66\", \"#EEC3FF\", \"#456D75\", \"#B77B68\", \"#7A87A1\", \"#788D66\", \"#885578\", \"#FAD09F\", \"#FF8A9A\", \"#D157A0\", \"#BEC459\", \"#456648\", \"#0086ED\", \"#886F4C\", \"#34362D\", \"#B4A8BD\", \"#00A6AA\", \"#452C2C\", \"#636375\", \"#A3C8C9\", \"#FF913F\", \"#938A81\", \"#575329\", \"#00FECF\", \"#B05B6F\", \"#8CD0FF\", \"#3B9700\", \"#04F757\", \"#C8A1A1\", \"#1E6E00\", \"#7900D7\", \"#A77500\", \"#6367A9\", \"#A05837\", \"#6B002C\", \"#772600\", \"#D790FF\", \"#9B9700\", \"#549E79\", \"#FFF69F\", \"#201625\", \"#72418F\", \"#BC23FF\", \"#99ADC0\", \"#3A2465\", \"#922329\", \"#5B4534\", \"#FDE8DC\", \"#404E55\", \"#0089A3\", \"#CB7E98\", \"#A4E804\", \"#324E72\", \"#6A3A4C\", \"#83AB58\", \"#001C1E\", \"#D1F7CE\", \"#004B28\", \"#C8D0F6\", \"#A3A489\", \"#806C66\", \"#222800\", \"#BF5650\", \"#E83000\", \"#66796D\", \"#DA007C\", \"#FF1A59\", \"#8ADBB4\", \"#1E0200\", \"#5B4E51\", \"#C895C5\", \"#320033\", \"#FF6832\", \"#66E1D3\", \"#CFCDAC\", \"#D0AC94\", \"#7ED379\", \"#012C58\"];\n  color = colors[index % colors.length];\n  return [parseInt(color.slice(1, 3), 16), parseInt(color.slice(3, 5), 16), parseInt(color.slice(5, 7), 16)];\n};\n\nForm = (function() {\n  function Form(data1, images1) {\n    this.data = data1;\n    this.images = images1;\n    this.toObject = bind(this.toObject, this);\n    this.toImage = bind(this.toImage, this);\n    this.match = bind(this.match, this);\n  }\n\n  Form.prototype.match = function(formSchema, cb) {\n    var anchors, fallbackScale, formData, schemaToFields, schemaToPage;\n    formData = {};\n    if (typeof formSchema.schemaToPage === 'function') {\n      schemaToPage = formSchema.schemaToPage;\n    } else if (formSchema.page != null) {\n      fallbackScale = this.images[0].width / formSchema.page.width;\n      schemaToPage = estimateTransform(formSchema.words, this.data[2], fallbackScale);\n    }\n    matchBarcodes(formData, formSchema, this.data[1], schemaToPage);\n    anchors = matchText(formData, formSchema, this.data[2], schemaToPage, this.images[0]).anchors;\n    this.anchors = anchors;\n    schemaToFields = estimateTransform(formSchema.fields, formData, 1, 1, matchByPath);\n    matchCheckboxes(formData, formSchema, this.data[3], this.data[2], schemaToPage, schemaToFields);\n    async.forEach(formSchema.fields, function(field, nextField) {\n      if (field.formValidator != null) {\n        return field.formValidator(formData, nextField);\n      } else {\n        return nextField();\n      }\n    }, function(err) {\n      if (err != null) {\n        return cb(err);\n      }\n      return cb(null, formData);\n    });\n  };\n\n  Form.prototype.toImage = function() {\n    var anchor, box, boxed, boxedIndex, candidateBox, color, data, i, image, imageBox, imageOffset, index, j, k, l, len, len1, len2, len3, len4, m, ref, ref1, ref2, ref3, ref4, resultImage;\n    resultImage = new dv.Image(this.images[0].width * this.images.length, this.images[0].height, 32);\n    imageOffset = (function(_this) {\n      return function(box, index) {\n        return {\n          x: box.x + _this.images[0].width * index,\n          y: box.y,\n          width: box.width,\n          height: box.height\n        };\n      };\n    })(this);\n    imageBox = {\n      x: 0,\n      y: 0,\n      width: this.images[0].width,\n      height: this.images[0].height\n    };\n    ref = this.images;\n    for (index = i = 0, len = ref.length; i < len; index = ++i) {\n      image = ref[index];\n      if (image != null) {\n        resultImage.drawImage(image.toColor(), imageOffset(imageBox, index));\n      }\n    }\n    ref1 = this.data.slice(1);\n    for (index = j = 0, len1 = ref1.length; j < len1; index = ++j) {\n      data = ref1[index];\n      if (data != null) {\n        for (boxedIndex = k = 0, len2 = data.length; k < len2; boxedIndex = ++k) {\n          boxed = data[boxedIndex];\n          try {\n            ref2 = boxed.candidate;\n            for (l = 0, len3 = ref2.length; l < len3; l++) {\n              candidateBox = ref2[l];\n              color = distinctColor(boxedIndex);\n              resultImage.drawBox(imageOffset(candidateBox, index), 6, color[0], color[1], color[2], 0.5);\n            }\n          } catch (undefined) {}\n          try {\n            resultImage.drawBox(imageOffset(boxed.box, index), 2, 0, 0, 255, 0.5);\n          } catch (undefined) {}\n        }\n      }\n    }\n    ref4 = (ref3 = this.anchors) != null ? ref3 : [];\n    for (index = m = 0, len4 = ref4.length; m < len4; index = ++m) {\n      anchor = ref4[index];\n      box = {\n        x: anchor.word.box.x + anchor.offset.x,\n        y: anchor.word.box.y + anchor.offset.y,\n        width: anchor.word.box.width,\n        height: anchor.word.box.height\n      };\n      resultImage.drawBox(imageOffset(box, 1), 4, 0, 255, 50, 0.5);\n      resultImage.drawLine(imageOffset(box, 1), imageOffset(anchor.word.box, 1), 4, 0, 255, 255, 0.5);\n    }\n    return resultImage;\n  };\n\n  Form.prototype.toObject = function() {\n    return {\n      barcodes: this.data[1],\n      text: this.data[2],\n      checkboxes: this.data[3]\n    };\n  };\n\n  return Form;\n\n})();\n\nmodule.exports = FormReader = (function() {\n  function FormReader(language, image1) {\n    if (language == null) {\n      language = 'eng';\n    }\n    this.image = image1 != null ? image1 : null;\n    this.find = bind(this.find, this);\n    this.tesseract = new dv.Tesseract(language);\n    this.tesseract.pageSegMode = 'single_block';\n    this.tesseract.classify_enable_learning = 0;\n    this.tesseract.classify_enable_adaptive_matcher = 0;\n    this.zxing = new dv.ZXing();\n  }\n\n  FormReader.prototype.find = function() {\n    var data, images, ref, ref1, ref2;\n    data = [null, null, null, null];\n    images = [this.image, null, null, null];\n    ref = findBarcodes(images[0], this.zxing), data[1] = ref[0], images[1] = ref[1];\n    ref1 = findText(images[1], this.tesseract), data[2] = ref1[0], images[2] = ref1[1];\n    ref2 = findCheckboxes(images[2]), data[3] = ref2[0], images[3] = ref2[1];\n    return new Form(data, images);\n  };\n\n  return FormReader;\n\n})();\n","/home/travis/build/npmtest/node-npmtest-fv/node_modules/fv/lib/estimate_transform.js":"// Generated by CoffeeScript 1.10.0\nvar avgMedian3, matchText;\n\nmatchText = function(word, words) {\n  var item, matches;\n  matches = (function() {\n    var k, len, results;\n    results = [];\n    for (k = 0, len = words.length; k < len; k++) {\n      item = words[k];\n      if (item.text === word.text) {\n        results.push(item);\n      }\n    }\n    return results;\n  })();\n  if (matches.length === 1) {\n    return matches[0];\n  }\n};\n\navgMedian3 = function(values) {\n  var averagingValues, count, k, len, median, sum, value;\n  if (values.length > 3) {\n    values.sort();\n    median = Math.floor(values.length / 2);\n    averagingValues = values.slice(median - 1, +(median + 1) + 1 || 9e9);\n  } else {\n    averagingValues = values;\n  }\n  sum = 0;\n  count = averagingValues.length;\n  for (k = 0, len = averagingValues.length; k < len; k++) {\n    value = averagingValues[k];\n    sum += value;\n  }\n  if (count > 0) {\n    return sum / count;\n  }\n};\n\nmodule.exports.estimateTransform = function(itemsA, itemsB, fallbackScale, requiredMatchCount, findMatch) {\n  var angle, byDistX, byDistY, distX, distY, expectedAngle, i, index, item, itemA1, itemA2, itemB1, itemB2, j, k, l, len, len1, m, matches, offsetX, offsetY, ref, ref1, scaleX, scaleY, transforms;\n  if (requiredMatchCount == null) {\n    requiredMatchCount = 7;\n  }\n  if (findMatch == null) {\n    findMatch = matchText;\n  }\n  matches = new Array(itemsA.length);\n  for (index = k = 0, len = itemsA.length; k < len; index = ++k) {\n    item = itemsA[index];\n    matches[index] = findMatch(item, itemsB);\n  }\n  transforms = [];\n  for (i = l = 0, len1 = itemsA.length; l < len1; i = ++l) {\n    itemA1 = itemsA[i];\n    if (itemB1 = matches[i]) {\n      for (j = m = ref = i + 1, ref1 = itemsA.length; m < ref1; j = m += 1) {\n        itemA2 = itemsA[j];\n        if (itemB2 = matches[j]) {\n          distX = Math.abs(itemB1.box.x - itemB2.box.x);\n          distY = Math.abs(itemB1.box.y - itemB2.box.y);\n          angle = Math.atan2(itemB1.box.x - itemB2.box.x, itemB1.box.y - itemB2.box.y);\n          expectedAngle = Math.atan2(itemA1.box.x - itemA2.box.x, itemA1.box.y - itemA2.box.y);\n          if (distX + distY > 1000 && Math.abs(angle - expectedAngle) < 0.02) {\n            scaleX = distX / Math.abs(itemA1.box.x - itemA2.box.x);\n            scaleY = distY / Math.abs(itemA1.box.y - itemA2.box.y);\n            transforms.push({\n              distance: [distX, distY],\n              scale: [scaleX, scaleY],\n              offset: [itemB1.box.x - itemA1.box.x * scaleX, itemB1.box.y - itemA1.box.y * scaleY]\n            });\n          }\n        }\n      }\n    }\n  }\n  if (transforms.length > requiredMatchCount) {\n    byDistX = transforms.filter(function(i) {\n      return i.distance[0] > 20;\n    }).sort(function(a, b) {\n      return a.distance[0] - b.distance[0];\n    });\n    scaleX = avgMedian3((function() {\n      var len2, n, ref2, results;\n      ref2 = byDistX.slice(-7);\n      results = [];\n      for (n = 0, len2 = ref2.length; n < len2; n++) {\n        i = ref2[n];\n        results.push(i.scale[0]);\n      }\n      return results;\n    })());\n    offsetX = avgMedian3((function() {\n      var len2, n, ref2, results;\n      ref2 = byDistX.slice(-7);\n      results = [];\n      for (n = 0, len2 = ref2.length; n < len2; n++) {\n        i = ref2[n];\n        results.push(i.offset[0]);\n      }\n      return results;\n    })());\n    byDistY = transforms.filter(function(i) {\n      return i.distance[1] > 20;\n    }).sort(function(a, b) {\n      return a.distance[1] - b.distance[1];\n    });\n    scaleY = avgMedian3((function() {\n      var len2, n, ref2, results;\n      ref2 = byDistY.slice(-7);\n      results = [];\n      for (n = 0, len2 = ref2.length; n < len2; n++) {\n        i = ref2[n];\n        results.push(i.scale[1]);\n      }\n      return results;\n    })());\n    offsetY = avgMedian3((function() {\n      var len2, n, ref2, results;\n      ref2 = byDistY.slice(-7);\n      results = [];\n      for (n = 0, len2 = ref2.length; n < len2; n++) {\n        i = ref2[n];\n        results.push(i.offset[1]);\n      }\n      return results;\n    })());\n  } else {\n    scaleX = fallbackScale;\n    scaleY = fallbackScale;\n    offsetX = 0;\n    offsetY = 0;\n  }\n  return function(box) {\n    return {\n      x: box.x * scaleX + offsetX,\n      y: box.y * scaleY + offsetY,\n      width: box.width * scaleX,\n      height: box.height * scaleY\n    };\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-fv/node_modules/fv/lib/find_barcodes.js":"// Generated by CoffeeScript 1.10.0\nvar QUIETZONE_WIDTH, boundingBox, cloneWithQuietZone, detectCandidates, dv;\n\ndv = require('dv');\n\nboundingBox = require('./math').boundingBox;\n\nQUIETZONE_WIDTH = 35;\n\ndetectCandidates = function(image) {\n  var blobImage, blobMap, blobMask;\n  blobImage = image.thin('bg', 8, 5).dilate(5, 3);\n  blobMap = blobImage.distanceFunction(8);\n  blobMask = blobMap.threshold(10).invert().dilate(42, 22);\n  return blobMask.connectedComponents(8);\n};\n\ncloneWithQuietZone = function(image, rect) {\n  var clone, cropped;\n  cropped = image.crop(rect);\n  clone = new dv.Image(cropped.width + QUIETZONE_WIDTH * 2, cropped.height + QUIETZONE_WIDTH * 2, cropped.depth);\n  clone.clearBox(0, 0, clone.width, clone.height);\n  clone.drawImage(cropped, QUIETZONE_WIDTH, QUIETZONE_WIDTH, cropped.width, cropped.height);\n  return clone;\n};\n\nmodule.exports.findBarcodes = function(image, zxing) {\n  var candidate, clearedImage, code, codes, couldBeRotated, grayImage, i, len, point, ref;\n  clearedImage = new dv.Image(image);\n  grayImage = image.toGray();\n  codes = [];\n  ref = detectCandidates(grayImage);\n  for (i = 0, len = ref.length; i < len; i++) {\n    candidate = ref[i];\n    try {\n      couldBeRotated = candidate.height * 1.75 > candidate.width;\n      zxing.image = cloneWithQuietZone(grayImage, candidate);\n      zxing.tryHarder = couldBeRotated;\n      code = zxing.findCode();\n      if ((code == null) && candidate.width < 0.3 * grayImage.width) {\n        zxing.image = zxing.image.scale(2).open(5, 3).scale(0.5).otsuAdaptiveThreshold(400, 400, 0, 0, 0.1).image;\n        code = zxing.findCode();\n      }\n      if (code != null) {\n        if (candidate.width < 0.3 * grayImage.width) {\n          clearedImage.clearBox(candidate);\n        }\n        code.box = boundingBox((function() {\n          var j, len1, ref1, results;\n          ref1 = code.points;\n          results = [];\n          for (j = 0, len1 = ref1.length; j < len1; j++) {\n            point = ref1[j];\n            results.push({\n              x: point.x,\n              y: point.y,\n              width: 1,\n              height: 1\n            });\n          }\n          return results;\n        })());\n        if (code.box.width < 20) {\n          code.box.y -= QUIETZONE_WIDTH;\n          code.box.x -= Math.round(candidate.width / 2);\n          code.box.width += candidate.width;\n          code.box.height += QUIETZONE_WIDTH * 2;\n        }\n        if (code.box.height < 20) {\n          code.box.x -= QUIETZONE_WIDTH;\n          code.box.y -= Math.round(candidate.height / 2);\n          code.box.height += candidate.height;\n          code.box.width += QUIETZONE_WIDTH * 2;\n        }\n        code.box.x += candidate.x - QUIETZONE_WIDTH;\n        code.box.y += candidate.y - QUIETZONE_WIDTH;\n        delete code.points;\n        codes.push(code);\n      }\n    } catch (undefined) {}\n  }\n  return [codes, clearedImage];\n};\n","/home/travis/build/npmtest/node-npmtest-fv/node_modules/fv/lib/find_checkboxes.js":"// Generated by CoffeeScript 1.10.0\nvar LOWER_CERTAIN_SCORE, LOWER_UNCERTAIN_SCORE, QUIETZONE_WIDTH, UPPER_CERTAIN_SCORE, UPPER_UNCERTAIN_SCORE, binarize, detectCandidates, dv, scoreCandidate, scoreToCheckState;\n\ndv = require('dv');\n\nbinarize = require('./filters/binarize');\n\nQUIETZONE_WIDTH = 10;\n\nLOWER_UNCERTAIN_SCORE = 0.02;\n\nLOWER_CERTAIN_SCORE = 0.10;\n\nUPPER_CERTAIN_SCORE = 1.5;\n\nUPPER_UNCERTAIN_SCORE = 4;\n\ndetectCandidates = function(binarizedImage) {\n  var candidate, candidates, i, innerCandidate, j, len, len1, ref, ref1, ref2, ref3, ref4, ref5;\n  candidates = [];\n  ref = binarizedImage.dilate(3, 3).connectedComponents(8);\n  for (i = 0, len = ref.length; i < len; i++) {\n    candidate = ref[i];\n    if ((0.5 < (ref1 = candidate.width / candidate.height) && ref1 < 5) && (10 < (ref2 = candidate.width) && ref2 < (binarizedImage.width / 3))) {\n      candidates.push(candidate);\n    } else if (candidate.width > (binarizedImage.width / 3)) {\n      ref3 = binarizedImage.crop(candidate).erode(3, 3).dilate(5, 5).connectedComponents(8);\n      for (j = 0, len1 = ref3.length; j < len1; j++) {\n        innerCandidate = ref3[j];\n        if ((0.5 < (ref4 = innerCandidate.width / innerCandidate.height) && ref4 < 2) && (20 < (ref5 = innerCandidate.width) && ref5 < (binarizedImage.width / 3))) {\n          innerCandidate.x += candidate.x;\n          innerCandidate.y += candidate.y;\n          candidates.push(innerCandidate);\n        }\n      }\n    }\n  }\n  return candidates;\n};\n\nscoreCandidate = function(binarizedImage, candidate) {\n  var candidateImage, distanceImage, imageWithGapsClosed, imageWithWeightedPixels, index, overscannedCandidate, ref, score, value;\n  overscannedCandidate = {\n    x: candidate.x - QUIETZONE_WIDTH,\n    y: candidate.y - QUIETZONE_WIDTH,\n    width: candidate.width + QUIETZONE_WIDTH * 2,\n    height: candidate.height + QUIETZONE_WIDTH * 2\n  };\n  candidateImage = binarizedImage.crop(overscannedCandidate);\n  imageWithGapsClosed = candidateImage.dilate(31, 31).erode(31, 31);\n  distanceImage = imageWithGapsClosed.distanceFunction(8);\n  imageWithWeightedPixels = distanceImage.and(candidateImage.invert().toGray());\n  score = 0;\n  ref = imageWithWeightedPixels.histogram();\n  for (value in ref) {\n    index = ref[value];\n    score += index * value;\n  }\n  return score;\n};\n\nscoreToCheckState = (function(_this) {\n  return function(score) {\n    var checked, confidence, lerp;\n    lerp = function(x, zeroAt, oneAt) {\n      return (x - zeroAt) / (oneAt - zeroAt);\n    };\n    checked = (LOWER_UNCERTAIN_SCORE < score && score < UPPER_UNCERTAIN_SCORE);\n    confidence = (function() {\n      switch (false) {\n        case !(score < LOWER_UNCERTAIN_SCORE):\n          return lerp(score, LOWER_UNCERTAIN_SCORE, 0);\n        case !((LOWER_UNCERTAIN_SCORE <= score && score < LOWER_CERTAIN_SCORE)):\n          return lerp(score, LOWER_UNCERTAIN_SCORE, LOWER_CERTAIN_SCORE);\n        case !((LOWER_CERTAIN_SCORE <= score && score < UPPER_CERTAIN_SCORE)):\n          return 1.0;\n        case !((UPPER_CERTAIN_SCORE <= score && score < UPPER_UNCERTAIN_SCORE)):\n          return lerp(score, UPPER_UNCERTAIN_SCORE, UPPER_CERTAIN_SCORE);\n        default:\n          return 0.0;\n      }\n    })();\n    confidence = Math.round(confidence * 92 + 5);\n    return [checked, confidence];\n  };\n})(this);\n\nmodule.exports.findCheckboxes = function(image) {\n  var binarizedImage, box, candidates, checked, clearedImage, confidence, i, len, marks, ref, score;\n  marks = [];\n  clearedImage = new dv.Image(image);\n  binarizedImage = binarize(image);\n  candidates = detectCandidates(binarizedImage);\n  for (i = 0, len = candidates.length; i < len; i++) {\n    box = candidates[i];\n    score = scoreCandidate(binarizedImage, box);\n    ref = scoreToCheckState(score), checked = ref[0], confidence = ref[1];\n    if (confidence > 0) {\n      marks.push({\n        box: box,\n        checked: checked,\n        confidence: confidence\n      });\n      clearedImage.clearBox(box);\n    }\n  }\n  return [marks, clearedImage];\n};\n","/home/travis/build/npmtest/node-npmtest-fv/node_modules/fv/lib/find_text.js":"// Generated by CoffeeScript 1.10.0\nvar boundingBox, boxDistanceVector, cloneUsingRegion, detectCandidates, detectLineMask, distanceVector, dv, findWords, intersectBox, isSameBlock, length, mergeRegions, ref;\n\ndv = require('dv');\n\nref = require('./math'), length = ref.length, distanceVector = ref.distanceVector, boxDistanceVector = ref.boxDistanceVector, intersectBox = ref.intersectBox, boundingBox = ref.boundingBox;\n\ndetectLineMask = function(image, minLineLength) {\n  var k, len, line, lineMask, longLines;\n  lineMask = new dv.Image(image.width, image.height, 8);\n  longLines = image.toGray().lineSegments(0, 0, false).filter(function(line) {\n    return length(distanceVector(line.p1, line.p2)) >= minLineLength;\n  });\n  for (k = 0, len = longLines.length; k < len; k++) {\n    line = longLines[k];\n    lineMask.drawLine(line.p1, line.p2, 7, 'set');\n  }\n  return lineMask;\n};\n\nmergeRegions = function(items, predicate) {\n  var done, i, item, j, jj, k, l, len, len1, m, n, otherItem, ref1, ref2, ref3, region, regions, results;\n  regions = (function() {\n    results = [];\n    for (var k = 0, ref1 = items.length; 0 <= ref1 ? k < ref1 : k > ref1; 0 <= ref1 ? k++ : k--){ results.push(k); }\n    return results;\n  }).apply(this);\n  done = false;\n  while (!done) {\n    done = true;\n    for (i = l = 0, len = items.length; l < len; i = ++l) {\n      item = items[i];\n      ref2 = items.slice(i + 1);\n      for (j = m = 0, len1 = ref2.length; m < len1; j = ++m) {\n        otherItem = ref2[j];\n        jj = j + i + 1;\n        if (regions[jj] !== regions[i] && predicate(item, otherItem)) {\n          region = Math.min(regions[jj], regions[i]);\n          regions[i] = regions[jj] = region;\n          done = false;\n        }\n      }\n    }\n    for (i = n = 0, ref3 = regions.length; 0 <= ref3 ? n <= ref3 : n >= ref3; i = 0 <= ref3 ? ++n : --n) {\n      while (regions[regions[i]] !== regions[i]) {\n        regions[i] = regions[regions[i]];\n      }\n    }\n  }\n  return regions;\n};\n\nisSameBlock = function(fontWidth, fontHeight) {\n  return function(boxA, boxB) {\n    var bottomA, bottomB, delta, sameLine;\n    bottomA = boxA.y + boxA.height;\n    bottomB = boxB.y + boxB.height;\n    delta = boxDistanceVector(boxA, boxB);\n    sameLine = Math.abs(bottomA - bottomB) < fontHeight / 2 && delta.x < fontWidth * 3;\n    return sameLine || intersectBox(boxA, boxB);\n  };\n};\n\ndetectCandidates = function(binarizedImage, fontWidth, fontHeight) {\n  var _, boxIndex, boxes, boxesByRegion, candidates, hasLetterSize, k, len, region, regions, smearHeight, smearWidth;\n  if (fontWidth == null) {\n    fontWidth = 20;\n  }\n  if (fontHeight == null) {\n    fontHeight = 30;\n  }\n  hasLetterSize = function(box) {\n    var ref1;\n    return fontWidth / 2 < box.width && (fontHeight / 2 < (ref1 = box.height) && ref1 < fontHeight * 6);\n  };\n  smearWidth = (1 * fontWidth) + fontWidth % 2;\n  smearHeight = (0.25 * fontHeight) + fontHeight % 2;\n  boxes = binarizedImage.dilate(smearWidth, smearHeight).connectedComponents(8).filter(hasLetterSize);\n  regions = mergeRegions(boxes, isSameBlock(fontWidth, fontHeight));\n  boxesByRegion = {};\n  for (boxIndex = k = 0, len = regions.length; k < len; boxIndex = ++k) {\n    region = regions[boxIndex];\n    if (boxesByRegion[region] == null) {\n      boxesByRegion[region] = [];\n    }\n    boxesByRegion[region].push(boxes[boxIndex]);\n  }\n  candidates = (function() {\n    var results;\n    results = [];\n    for (_ in boxesByRegion) {\n      boxes = boxesByRegion[_];\n      results.push(boxes);\n    }\n    return results;\n  })();\n  return candidates;\n};\n\ncloneUsingRegion = function(image, boxes) {\n  var box, cloneBox, cloneImage, k, len;\n  cloneBox = boundingBox(boxes);\n  cloneImage = new dv.Image(cloneBox.width, cloneBox.height, image.depth);\n  cloneImage.clearBox({\n    x: 0,\n    y: 0,\n    width: cloneBox.width,\n    height: cloneBox.height\n  });\n  for (k = 0, len = boxes.length; k < len; k++) {\n    box = boxes[k];\n    cloneImage.drawImage(image.crop(box.x, box.y, box.width + 25, box.height), {\n      x: box.x - cloneBox.x,\n      y: box.y - cloneBox.y,\n      width: box.width + 25,\n      height: box.height\n    });\n  }\n  return [cloneImage, cloneBox];\n};\n\nfindWords = function(candidates, image, tesseract) {\n  var candidateBoxes, cloneBox, cloneImage, k, l, len, len1, localWords, ref1, word, words;\n  words = [];\n  for (k = 0, len = candidates.length; k < len; k++) {\n    candidateBoxes = candidates[k];\n    ref1 = cloneUsingRegion(image, candidateBoxes), cloneImage = ref1[0], cloneBox = ref1[1];\n    tesseract.image = cloneImage;\n    tesseract.pageSegMode = cloneBox.height < 60 ? 'single_line' : 'single_block';\n    localWords = tesseract.findWords();\n    for (l = 0, len1 = localWords.length; l < len1; l++) {\n      word = localWords[l];\n      word.box.x += cloneBox.x;\n      word.box.y += cloneBox.y;\n      word.candidate = candidateBoxes.slice(0);\n    }\n    words = words.concat(localWords);\n  }\n  words = words.filter(function(word) {\n    return word.box.width > 5 && word.box.height > 5;\n  });\n  return words;\n};\n\nmodule.exports.findText = function(image, tesseract) {\n  var candidates, clearedImage, k, len, lineMask, textImage, word, words;\n  clearedImage = new dv.Image(image);\n  lineMask = detectLineMask(image, 45);\n  textImage = image.toGray().add(lineMask.toGray());\n  tesseract.image = textImage;\n  candidates = detectCandidates(textImage.otsuAdaptiveThreshold(128, 128, 0, 0, 0).image);\n  words = findWords(candidates, image, tesseract);\n  for (k = 0, len = words.length; k < len; k++) {\n    word = words[k];\n    if (word.text.length >= 6 || (word.text.length >= 3 && word.confidence >= 30)) {\n      clearedImage.clearBox(word.box);\n    }\n  }\n  return [words, clearedImage];\n};\n","/home/travis/build/npmtest/node-npmtest-fv/node_modules/fv/lib/match_barcodes.js":"// Generated by CoffeeScript 1.10.0\nvar barcodeToValue, center, distanceVector, length, ref, ref1, unpack, validate;\n\nref = require('./schema'), unpack = ref.unpack, validate = ref.validate;\n\nref1 = require('./math'), distanceVector = ref1.distanceVector, length = ref1.length, center = ref1.center;\n\nbarcodeToValue = function(barcode) {\n  return {\n    type: barcode.type,\n    data: barcode.data,\n    buffer: barcode.buffer\n  };\n};\n\nmodule.exports.matchBarcodes = function(formData, formSchema, barcodes, schemaToPage) {\n  var barcode, barcodeFields, choice, confidence, distance, field, fieldData, i, j, k, len, len1, len2, matchMap, matches, name, projection, radius, validFields, value, values;\n  barcodeFields = formSchema.fields.filter(function(field) {\n    return field.type === 'barcode';\n  });\n  matchMap = {};\n  for (i = 0, len = barcodes.length; i < len; i++) {\n    barcode = barcodes[i];\n    value = barcodeToValue(barcode);\n    validFields = barcodeFields.filter(function(field) {\n      return validate(field, value, false);\n    });\n    for (j = 0, len1 = validFields.length; j < len1; j++) {\n      field = validFields[j];\n      if (field.searchRadius > 0) {\n        projection = schemaToPage(field.box);\n        distance = length(distanceVector(center(projection), center(barcode.box)));\n        radius = Math.max(projection.width, projection.height) / 2;\n        if (distance > radius * field.searchRadius) {\n          continue;\n        }\n      }\n      if (matchMap[name = field.path] == null) {\n        matchMap[name] = [];\n      }\n      matchMap[field.path].push({\n        barcode: barcode,\n        paths: validFields.map(function(field) {\n          return field.path;\n        })\n      });\n    }\n  }\n  for (k = 0, len2 = barcodeFields.length; k < len2; k++) {\n    field = barcodeFields[k];\n    if (matchMap[field.path] != null) {\n      matches = matchMap[field.path];\n      if (matches.length > 1 && (field.fieldSelector != null)) {\n        values = matches.map(function(match) {\n          return barcodeToValue(match.barcode);\n        });\n        choice = field.fieldSelector(values);\n        confidence = 100;\n        if (!(choice in values)) {\n          throw new Error('Returned choice index out of bounds');\n        }\n      } else {\n        choice = 0;\n        confidence = 100 / matches.length;\n      }\n      fieldData = unpack(formData, field.path);\n      fieldData.value = barcodeToValue(matches[choice].barcode);\n      fieldData.confidence = confidence;\n      fieldData.box = matches[choice].barcode.box;\n      fieldData.conflicts = matches[choice].paths.filter(function(path) {\n        return path !== field.path;\n      });\n    } else {\n      fieldData = unpack(formData, field.path);\n      fieldData.confidence = 0;\n      fieldData.box = schemaToPage(field.box);\n      fieldData.conflicts = [];\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-fv/node_modules/fv/lib/schema.js":"// Generated by CoffeeScript 1.10.0\nmodule.exports.unpack = function(object, path) {\n  var i, item, len, ref, tail;\n  tail = object;\n  ref = path.split('.');\n  for (i = 0, len = ref.length; i < len; i++) {\n    item = ref[i];\n    if (tail[item] == null) {\n      tail[item] = {};\n    }\n    tail = tail[item];\n  }\n  return tail;\n};\n\nmodule.exports.validate = function(field, value, defaultResult) {\n  if (field.fieldValidator != null) {\n    return Boolean(field.fieldValidator(value));\n  } else {\n    return defaultResult;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-fv/node_modules/fv/lib/math.js":"// Generated by CoffeeScript 1.10.0\nmodule.exports.length = function(vector) {\n  return Math.sqrt(vector.x * vector.x + vector.y * vector.y);\n};\n\nmodule.exports.distance = function(boxA, boxB) {\n  var center1X, center1Y, center2X, center2Y, ref, ref1, ref2, ref3;\n  center1X = boxA.x + ((ref = boxA.width) != null ? ref : 0) / 2;\n  center1Y = boxA.y + ((ref1 = boxA.height) != null ? ref1 : 0) / 2;\n  center2X = boxB.x + ((ref2 = boxB.width) != null ? ref2 : 0) / 2;\n  center2Y = boxB.y + ((ref3 = boxB.height) != null ? ref3 : 0) / 2;\n  return Math.abs(center1X - center2X) + Math.abs(center1Y - center2Y);\n};\n\nmodule.exports.center = function(box) {\n  return {\n    x: box.x + box.width / 2,\n    y: box.y + box.height / 2\n  };\n};\n\nmodule.exports.distanceVector = function(vectorA, vectorB) {\n  return {\n    x: vectorA.x - vectorB.x,\n    y: vectorA.y - vectorB.y\n  };\n};\n\nmodule.exports.boxDistanceVector = function(boxA, boxB) {\n  return {\n    x: Math.max(boxA.x, boxB.x) - Math.min(boxA.x + boxA.width, boxB.x + boxB.width),\n    y: Math.max(boxA.y, boxB.y) - Math.min(boxA.y + boxA.height, boxB.y + boxB.height)\n  };\n};\n\nmodule.exports.intersectBox = function(boxA, boxB) {\n  return boxA.x < (boxB.x + boxB.width) && (boxA.x + boxA.width) > boxB.x && boxA.y < (boxB.y + boxB.height) && (boxA.y + boxA.height) > boxB.y;\n};\n\nmodule.exports.boundingBox = function(boxes) {\n  var box, i, len, maxX, maxY, minX, minY;\n  minX = Number.MAX_VALUE;\n  minY = Number.MAX_VALUE;\n  maxX = Number.MIN_VALUE;\n  maxY = Number.MIN_VALUE;\n  for (i = 0, len = boxes.length; i < len; i++) {\n    box = boxes[i];\n    if (!(box != null)) {\n      continue;\n    }\n    minX = Math.min(box.x, minX);\n    minY = Math.min(box.y, minY);\n    maxX = Math.max(box.x, maxX);\n    maxY = Math.max(box.y, maxY);\n    minX = Math.min(box.x + box.width, minX);\n    minY = Math.min(box.y + box.height, minY);\n    maxX = Math.max(box.x + box.width, maxX);\n    maxY = Math.max(box.y + box.height, maxY);\n  }\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-fv/node_modules/fv/lib/match_checkboxes.js":"// Generated by CoffeeScript 1.10.0\nvar distance, estimateTransform, findClosestMark, findClosestShortWord, matchByMark, matchByWords, ref, unpack, validate,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nref = require('./schema'), unpack = ref.unpack, validate = ref.validate;\n\nestimateTransform = require('./estimate_transform').estimateTransform;\n\ndistance = require('./math').distance;\n\nfindClosestShortWord = function(words, box, maxDistance) {\n  var closestIndex, dist, i, index, len, minDistance, word;\n  minDistance = maxDistance;\n  closestIndex = -1;\n  for (index = i = 0, len = words.length; i < len; index = ++i) {\n    word = words[index];\n    if (!(word.text.length < 3)) {\n      continue;\n    }\n    dist = distance(word.box, box);\n    if (dist < minDistance) {\n      minDistance = dist;\n      closestIndex = index;\n    }\n  }\n  return closestIndex;\n};\n\nmatchByWords = function(formData, fields, words, schemaToPage, schemaToData) {\n  var closeIndex, dataBox, field, fieldData, fieldIndex, i, index, j, len, len1, matchedFields, matches, wordUsage;\n  matchedFields = [];\n  matches = [];\n  wordUsage = [];\n  for (i = 0, len = fields.length; i < len; i++) {\n    field = fields[i];\n    dataBox = schemaToData(field.box);\n    closeIndex = findClosestShortWord(words, dataBox, dataBox.width);\n    if (closeIndex === -1) {\n      closeIndex = findClosestShortWord(words, schemaToPage(field.box), dataBox.width);\n    }\n    if (closeIndex === -1) {\n      continue;\n    }\n    if (validate(field, words[closeIndex].text, false)) {\n      if (wordUsage[closeIndex] == null) {\n        wordUsage[closeIndex] = [];\n      }\n      wordUsage[closeIndex].push(field.path);\n      matchedFields.push(field);\n      matches.push(closeIndex);\n    }\n  }\n  for (fieldIndex = j = 0, len1 = matchedFields.length; j < len1; fieldIndex = ++j) {\n    field = matchedFields[fieldIndex];\n    index = matches[fieldIndex];\n    fieldData = unpack(formData, field.path);\n    fieldData.value = words[index].text;\n    fieldData.confidence = words[index].confidence;\n    fieldData.box = words[index].box;\n    fieldData.conflicts = wordUsage[index].filter(function(path) {\n      return path !== field.path;\n    });\n  }\n  return matchedFields;\n};\n\nfindClosestMark = function(marks, box, maxDistance) {\n  var closestIndex, dist, i, index, len, mark, minDistance;\n  minDistance = maxDistance;\n  closestIndex = -1;\n  for (index = i = 0, len = marks.length; i < len; index = ++i) {\n    mark = marks[index];\n    dist = distance(mark.box, box);\n    if (dist < minDistance) {\n      minDistance = dist;\n      closestIndex = index;\n    }\n  }\n  return closestIndex;\n};\n\nmatchByMark = function(formData, fields, marks, schemaToPage) {\n  var closeIndex, farDistance, field, fieldData, i, j, len, len1, markUsage, match, matches, nearDistance, pageBox;\n  matches = {};\n  markUsage = [];\n  for (i = 0, len = fields.length; i < len; i++) {\n    field = fields[i];\n    pageBox = schemaToPage(field.box);\n    nearDistance = pageBox.width * 0.95;\n    farDistance = pageBox.width * 3.00;\n    closeIndex = findClosestMark(marks, pageBox, farDistance);\n    if (closeIndex === -1) {\n      matches[field.path] = {\n        index: -1,\n        value: false,\n        confidence: 100,\n        box: pageBox\n      };\n    } else if (distance(marks[closeIndex].box, pageBox) > nearDistance) {\n      matches[field.path] = {\n        index: -1,\n        value: false,\n        confidence: Math.round((distance(marks[closeIndex].box, pageBox) / farDistance) * 100),\n        box: pageBox\n      };\n    } else {\n      matches[field.path] = {\n        index: closeIndex,\n        value: marks[closeIndex].checked,\n        confidence: marks[closeIndex].confidence,\n        box: marks[closeIndex].box\n      };\n      if (markUsage[closeIndex] == null) {\n        markUsage[closeIndex] = [];\n      }\n      markUsage[closeIndex].push(field.path);\n    }\n  }\n  for (j = 0, len1 = fields.length; j < len1; j++) {\n    field = fields[j];\n    match = matches[field.path];\n    fieldData = unpack(formData, field.path);\n    fieldData.value = match.value;\n    fieldData.confidence = match.confidence;\n    fieldData.box = match.box;\n    if (match.index === -1) {\n      fieldData.conflicts = [];\n    } else {\n      fieldData.conflicts = markUsage[match.index].filter(function(path) {\n        return path !== field.path;\n      });\n    }\n  }\n};\n\nmodule.exports.matchCheckboxes = function(formData, formSchema, marks, words, schemaToPage, schemaToData) {\n  var assignedFields, checkboxFields, field, remainingFields;\n  checkboxFields = formSchema.fields.filter(function(field) {\n    return field.type === 'checkbox';\n  });\n  assignedFields = matchByWords(formData, checkboxFields, words, schemaToPage, schemaToData);\n  remainingFields = (function() {\n    var i, len, results;\n    results = [];\n    for (i = 0, len = checkboxFields.length; i < len; i++) {\n      field = checkboxFields[i];\n      if (indexOf.call(assignedFields, field) < 0) {\n        results.push(field);\n      }\n    }\n    return results;\n  })();\n  matchByMark(formData, remainingFields, marks, schemaToPage);\n};\n","/home/travis/build/npmtest/node-npmtest-fv/node_modules/fv/lib/match_text.js":"// Generated by CoffeeScript 1.10.0\nvar boundingBox, distance, estimateSymbolWidth, findAnchors, findClosestAnchor, findTwoClosestWords, findVariants, length, pixelsToConfidence, ref, ref1, selectWords, unpack, validate, wordsToConfidence, wordsToText,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nref = require('./schema'), unpack = ref.unpack, validate = ref.validate;\n\nref1 = require('./math'), distance = ref1.distance, length = ref1.length, boundingBox = ref1.boundingBox;\n\nfindAnchors = function(textFields, words, schemaToPage) {\n  var anchor, anchorFields, anchorWords, anchors, fieldIndex, index, j, k, l, len, len1, len2, matches, pageBox, textField, word, wordIndex;\n  anchors = [];\n  anchorFields = [];\n  anchorWords = [];\n  for (fieldIndex = j = 0, len = textFields.length; j < len; fieldIndex = ++j) {\n    textField = textFields[fieldIndex];\n    matches = [];\n    for (wordIndex = k = 0, len1 = words.length; k < len1; wordIndex = ++k) {\n      word = words[wordIndex];\n      if (word.text.length > 3) {\n        if (validate(textField, word.text, false)) {\n          matches.push(wordIndex);\n        }\n      }\n    }\n    if (matches.length === 1) {\n      word = words[matches[0]];\n      if (indexOf.call(anchorWords, word) >= 0) {\n        for (index = l = 0, len2 = anchors.length; l < len2; index = ++l) {\n          anchor = anchors[index];\n          if (anchor.word === word) {\n            anchors.splice(index, 1);\n            anchorFields.splice(index, 1);\n            break;\n          }\n        }\n        continue;\n      }\n      pageBox = schemaToPage(textField.box);\n      if (Math.abs(word.box.x - pageBox.x) + Math.abs(word.box.y - pageBox.y) > 400) {\n        continue;\n      }\n      anchor = {\n        acceptedBy: textField.path,\n        offset: {\n          x: pageBox.x - word.box.x,\n          y: pageBox.y - word.box.y\n        },\n        word: word\n      };\n      anchors.push(anchor);\n      anchorWords.push(word);\n    }\n  }\n  return anchors;\n};\n\nfindTwoClosestWords = function(pageBox, words) {\n  var wordDistances;\n  wordDistances = words.map(function(word) {\n    return {\n      distance: Math.abs(word.box.x - pageBox.x) + Math.abs(word.box.y - pageBox.y),\n      word: word\n    };\n  });\n  wordDistances = wordDistances.filter(function(i) {\n    return i.distance < 200;\n  });\n  wordDistances.sort(function(a, b) {\n    return a.distance - b.distance;\n  });\n  return wordDistances.slice(0, 2).map(function(item) {\n    return item.word;\n  });\n};\n\nselectWords = function(words, box) {\n  var bottom, diff, firstLine, firstLineDiff, j, k, len, len1, ref2, right, selectedWords, word;\n  selectedWords = [];\n  right = box.x + box.width;\n  bottom = box.y + box.height;\n  for (j = 0, len = words.length; j < len; j++) {\n    word = words[j];\n    if ((word.box.x + word.box.width / 2) < right && (word.box.x + word.box.width / 2) > box.x && word.box.y < bottom && word.box.y + word.box.height > box.y && ((ref2 = word.text) !== 'I' && ref2 !== '|' && ref2 !== '_' && ref2 !== '')) {\n      selectedWords.push(word);\n    }\n  }\n  firstLine = void 0;\n  firstLineDiff = Infinity;\n  for (k = 0, len1 = selectedWords.length; k < len1; k++) {\n    word = selectedWords[k];\n    diff = Math.abs(box.y - word.box.y);\n    if (diff < firstLineDiff) {\n      firstLine = word.box.y;\n      firstLineDiff = diff;\n    }\n  }\n  return (function() {\n    var l, len2, ref3, results;\n    results = [];\n    for (l = 0, len2 = selectedWords.length; l < len2; l++) {\n      word = selectedWords[l];\n      if ((firstLine - 10 <= (ref3 = word.box.y) && ref3 < firstLine + box.height - 5)) {\n        results.push(word);\n      }\n    }\n    return results;\n  })();\n};\n\nestimateSymbolWidth = function(word) {\n  var charWidth;\n  charWidth = word.box.width / word.text.length;\n  charWidth += 0.2 * charWidth / word.text.length;\n  return charWidth;\n};\n\nwordsToText = function(words, extendedGapDetection) {\n  var charWidth, fragment, gap, i, isFragment, j, k, l, lastWord, len, len1, len2, line, lines, minimumGap, spaces, text, word;\n  if (extendedGapDetection == null) {\n    extendedGapDetection = false;\n  }\n  lines = [[]];\n  lastWord = words[0];\n  words.sort(function(a, b) {\n    return a.box.y + a.box.height - b.box.y - b.box.height;\n  });\n  for (j = 0, len = words.length; j < len; j++) {\n    word = words[j];\n    if (Math.abs(lastWord.box.y + lastWord.box.height - word.box.y - word.box.height) > 15) {\n      lines.push([]);\n    }\n    lines[lines.length - 1].push(word);\n    lastWord = word;\n  }\n  text = '';\n  fragment = /^(|\\w|\\d\\d)\\/?$/;\n  for (i = k = 0, len1 = lines.length; k < len1; i = ++k) {\n    line = lines[i];\n    if (i !== 0) {\n      text += '\\n';\n    }\n    line.sort(function(a, b) {\n      return a.box.x - b.box.x;\n    });\n    gap = 0;\n    minimumGap = 50;\n    lastWord = null;\n    for (i = l = 0, len2 = line.length; l < len2; i = ++l) {\n      word = line[i];\n      isFragment = fragment.test(word.text);\n      if (lastWord != null) {\n        charWidth = (estimateSymbolWidth(lastWord) + estimateSymbolWidth(word)) / 2;\n        gap = word.box.x - (lastWord.box.x + lastWord.box.width);\n        if (extendedGapDetection) {\n          minimumGap = charWidth * 1.5;\n        }\n      }\n      if ((i === 0) || (isFragment && fragment.test(lastWord.text) && gap < minimumGap)) {\n        text += word.text;\n      } else if (extendedGapDetection && gap > charWidth * 2) {\n        spaces = Math.max(1, Math.floor(gap / charWidth));\n        text += '   '.slice(0, spaces) + word.text;\n      } else {\n        text += ' ' + word.text;\n      }\n      lastWord = word;\n    }\n  }\n  return text;\n};\n\nfindClosestAnchor = function(anchors, pageBox) {\n  var anchor, closest, dist, j, len, minDistance;\n  minDistance = Infinity;\n  closest = null;\n  for (j = 0, len = anchors.length; j < len; j++) {\n    anchor = anchors[j];\n    dist = Math.abs(anchor.word.box.x - pageBox.x) + Math.abs(anchor.word.box.y - pageBox.y);\n    if (dist < minDistance) {\n      minDistance = dist;\n      closest = anchor;\n    }\n  }\n  return closest;\n};\n\nwordsToConfidence = function(words) {\n  return Math.round(words.reduce((function(sum, word) {\n    return sum + word.confidence;\n  }), 0) / words.length);\n};\n\npixelsToConfidence = function(box, image) {\n  var blobImage, blobRatio, blobs, confidence, cropBox, x, y;\n  x = Math.max(0, Math.min(image.width - 1, box.x));\n  y = Math.max(0, Math.min(image.height - 1, box.y));\n  cropBox = {\n    x: x,\n    y: y,\n    width: Math.max(0, Math.min(image.width - x, box.width)),\n    height: Math.max(0, Math.min(image.height - y, box.height))\n  };\n  if (cropBox.width === 0 || cropBox.height === 0) {\n    return 50;\n  }\n  blobImage = image.crop(cropBox).threshold(248);\n  blobs = blobImage.connectedComponents(8).filter(function(box) {\n    return box.width > 4 && box.height > 6;\n  });\n  if (blobs.length > 0) {\n    box = boundingBox(blobs);\n    blobRatio = (box.width * box.height) / (blobImage.width * blobImage.height);\n    confidence = Math.max(0, Math.round((0.33 - blobRatio) * 100));\n  } else {\n    confidence = 100;\n  }\n  return confidence;\n};\n\nfindVariants = function(field, anchors, words, schemaToPage, image) {\n  var candidateText, candidateWords, closeWords, closestAnchor, epsilonConfidence, isDuplicate, isValid, j, k, len, len1, pageBox, searchBox, searchBoxes, variants, word;\n  pageBox = schemaToPage(field.box);\n  closestAnchor = findClosestAnchor(anchors, pageBox);\n  if (closestAnchor != null) {\n    pageBox.x -= closestAnchor.offset.x;\n    pageBox.y -= closestAnchor.offset.y;\n  }\n  closeWords = findTwoClosestWords(pageBox, words);\n  searchBoxes = [\n    {\n      x: pageBox.x,\n      y: pageBox.y,\n      width: pageBox.width,\n      height: pageBox.height,\n      priority: 0\n    }\n  ];\n  for (j = 0, len = closeWords.length; j < len; j++) {\n    word = closeWords[j];\n    searchBoxes.push({\n      x: word.box.x,\n      y: word.box.y,\n      width: pageBox.width,\n      height: pageBox.height,\n      priority: 2\n    });\n    searchBoxes.push({\n      x: word.box.x,\n      y: word.box.y,\n      width: pageBox.width * 0.9,\n      height: pageBox.height * 0.9,\n      priority: 3\n    });\n    searchBoxes.push({\n      x: word.box.x,\n      y: word.box.y,\n      width: pageBox.width * 1.1,\n      height: pageBox.height * 1.1,\n      priority: 3\n    });\n  }\n  variants = [];\n  for (k = 0, len1 = searchBoxes.length; k < len1; k++) {\n    searchBox = searchBoxes[k];\n    candidateWords = selectWords(words, searchBox);\n    if (candidateWords.length > 0) {\n      candidateText = wordsToText(candidateWords, field.extendedGapDetection);\n      isDuplicate = variants.some(function(variant) {\n        return variant.text === candidateText;\n      });\n      if (isDuplicate) {\n        continue;\n      }\n      isValid = validate(field, candidateText, true);\n      if (!isValid) {\n        continue;\n      }\n      variants.push({\n        path: field.path,\n        confidence: wordsToConfidence(candidateWords),\n        box: boundingBox((function() {\n          var l, len2, results;\n          results = [];\n          for (l = 0, len2 = candidateWords.length; l < len2; l++) {\n            word = candidateWords[l];\n            results.push(word.box);\n          }\n          return results;\n        })()),\n        text: candidateText,\n        words: candidateWords,\n        used: false,\n        priority: [isValid, searchBox.priority]\n      });\n    }\n  }\n  epsilonConfidence = pixelsToConfidence(pageBox, image);\n  if (epsilonConfidence > 50 || variants.length === 0) {\n    isValid = validate(field, '', false);\n    variants.push({\n      path: field.path,\n      confidence: epsilonConfidence,\n      box: pageBox,\n      text: '',\n      words: [],\n      used: false,\n      priority: [isValid, 1]\n    });\n  }\n  variants.sort(function(a, b) {\n    var deltaPriority, deltaValid;\n    deltaValid = b.priority[0] - a.priority[0];\n    deltaPriority = a.priority[1] - b.priority[1];\n    if (deltaValid === 0) {\n      return deltaPriority;\n    } else {\n      return deltaValid;\n    }\n  });\n  return variants;\n};\n\nmodule.exports.matchText = function(formData, formSchema, words, schemaToPage, rawImage) {\n  var anchors, choice, conflictingVariants, conflicts, field, fieldData, fieldIndex, image, j, k, l, len, len1, len10, len2, len3, len4, len5, len6, len7, len8, len9, m, n, o, p, path, q, r, ref2, ref3, ref4, ref5, ref6, ref7, s, selectedVariant, selectedVariants, t, textFields, values, variant, variants, variantsByPath, variantsByWord, word, wordIndex, wordUsage, wordVariant;\n  textFields = formSchema.fields.filter(function(field) {\n    return field.type === 'text';\n  });\n  if (textFields.length === 0) {\n    return {};\n  }\n  textFields.sort(function(a, b) {\n    var deltaX, deltaY;\n    deltaY = a.box.y - b.box.y;\n    deltaX = a.box.x - b.box.x;\n    if (Math.abs(deltaY) < 20) {\n      return deltaX;\n    } else {\n      return deltaY;\n    }\n  });\n  image = rawImage.toGray();\n  anchors = findAnchors(textFields, words, schemaToPage);\n  variantsByPath = {};\n  variantsByWord = {};\n  for (j = 0, len = textFields.length; j < len; j++) {\n    field = textFields[j];\n    variants = findVariants(field, anchors, words, schemaToPage, image);\n    variantsByPath[field.path] = variants;\n    for (k = 0, len1 = variants.length; k < len1; k++) {\n      variant = variants[k];\n      ref2 = variant.words;\n      for (l = 0, len2 = ref2.length; l < len2; l++) {\n        word = ref2[l];\n        wordIndex = words.indexOf(word);\n        if (variantsByWord[wordIndex] == null) {\n          variantsByWord[wordIndex] = [];\n        }\n        variantsByWord[wordIndex].push(variant);\n      }\n    }\n  }\n  for (m = 0, len3 = textFields.length; m < len3; m++) {\n    field = textFields[m];\n    variants = variantsByPath[field.path];\n    if (variants.length === 1 && variants[0].words.length === 1) {\n      word = variants[0].words[0];\n      wordIndex = words.indexOf(word);\n      ref3 = variantsByWord[wordIndex];\n      for (n = 0, len4 = ref3.length; n < len4; n++) {\n        variant = ref3[n];\n        if (variant.path === field.path) {\n          continue;\n        }\n        conflictingVariants = variantsByPath[variant.path];\n        if (conflictingVariants.length > 1) {\n          conflictingVariants.splice(conflictingVariants.indexOf(variant), 1);\n        }\n      }\n    }\n  }\n  selectedVariants = [];\n  wordUsage = [];\n  for (o = 0, len5 = textFields.length; o < len5; o++) {\n    field = textFields[o];\n    variants = variantsByPath[field.path].filter(function(variant) {\n      return !variant.used;\n    });\n    if (variants.length === 0) {\n      variants = variantsByPath[field.path];\n    }\n    if (variants.length > 1 && (field.fieldSelector != null)) {\n      values = variants.map(function(variant) {\n        return variant.text;\n      });\n      choice = field.fieldSelector(values);\n      if (!(choice in values)) {\n        throw new Error('Returned choice index out of bounds');\n      }\n    } else {\n      choice = 0;\n    }\n    selectedVariants.push(selectedVariant = variants[choice]);\n    ref4 = selectedVariant.words;\n    for (p = 0, len6 = ref4.length; p < len6; p++) {\n      word = ref4[p];\n      wordIndex = words.indexOf(word);\n      ref5 = variantsByWord[wordIndex];\n      for (q = 0, len7 = ref5.length; q < len7; q++) {\n        wordVariant = ref5[q];\n        wordVariant.used = true;\n      }\n      if (wordUsage[wordIndex] == null) {\n        wordUsage[wordIndex] = [];\n      }\n      wordUsage[wordIndex].push(field.path);\n    }\n  }\n  for (fieldIndex = r = 0, len8 = textFields.length; r < len8; fieldIndex = ++r) {\n    field = textFields[fieldIndex];\n    selectedVariant = selectedVariants[fieldIndex];\n    conflicts = [field.path];\n    ref6 = selectedVariant.words;\n    for (s = 0, len9 = ref6.length; s < len9; s++) {\n      word = ref6[s];\n      wordIndex = words.indexOf(word);\n      ref7 = wordUsage[wordIndex];\n      for (t = 0, len10 = ref7.length; t < len10; t++) {\n        path = ref7[t];\n        if (indexOf.call(conflicts, path) < 0) {\n          conflicts.push(path);\n        }\n      }\n    }\n    conflicts.splice(0, 1);\n    fieldData = unpack(formData, field.path);\n    fieldData.value = selectedVariant.text;\n    fieldData.confidence = selectedVariant.confidence;\n    fieldData.box = selectedVariant.box;\n    fieldData.conflicts = conflicts;\n  }\n  return {\n    anchors: anchors\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-fv/node_modules/fv/lib/filters/binarize.js":"// Generated by CoffeeScript 1.10.0\nvar dv, tesseractInstance;\n\ndv = require('dv');\n\ntesseractInstance = null;\n\nmodule.exports = function(image) {\n  if (tesseractInstance == null) {\n    tesseractInstance = new dv.Tesseract();\n  }\n  tesseractInstance.image = image;\n  return tesseractInstance.thresholdImage();\n};\n","/home/travis/build/npmtest/node-npmtest-fv/node_modules/fv/lib/filters/darken_ink.js":"// Generated by CoffeeScript 1.10.0\nvar dv;\n\ndv = require('dv');\n\nmodule.exports = function(image) {\n  var curve, darkValueMask, deltaV, desaturatedMask, h, hsv, i, j, k, l, len, protectionMask, rect, ref, results, s, v, vOrig, x;\n  hsv = image.toColor().toHSV();\n  desaturatedMask = hsv.inRange(0, 0, 0, 239, 0.1 * 255, 255);\n  darkValueMask = hsv.inRange(0, 0, 0, 239, 255, 0.5 * 255).invert();\n  h = hsv.toGray(1, 0, 0);\n  s = hsv.toGray(0, 1, 0);\n  v = hsv.toGray(0, 0, 1);\n  vOrig = new dv.Image(v);\n  curve = (function() {\n    results = [];\n    for (i = 0; i <= 255; i++){ results.push(i); }\n    return results;\n  }).apply(this);\n  for (x = j = 0; j <= 199; x = ++j) {\n    curve[x] = 0;\n  }\n  for (x = k = 0; k <= 54; x = ++k) {\n    curve[x + 200] = x / 54 * 220;\n  }\n  protectionMask = desaturatedMask.and(darkValueMask.erode(5, 5));\n  v.applyCurve(curve, protectionMask);\n  deltaV = vOrig.subtract(v);\n  deltaV = deltaV.invert();\n  ref = deltaV.threshold(254).dilate(5, 5).connectedComponents(8);\n  for (l = 0, len = ref.length; l < len; l++) {\n    rect = ref[l];\n    if (rect.height > 100 || rect.width < 5 || rect.height < 5) {\n      deltaV.clearBox(rect);\n    }\n  }\n  deltaV = deltaV.invert();\n  v = vOrig.subtract(deltaV);\n  return new dv.Image(h, s, v).toRGB();\n};\n","/home/travis/build/npmtest/node-npmtest-fv/node_modules/fv/lib/filters/deskew.js":"// Generated by CoffeeScript 1.10.0\nvar dv;\n\ndv = require('dv');\n\nmodule.exports = function(image) {\n  var binarizedImage, grayImage, skew;\n  grayImage = image.toGray();\n  binarizedImage = grayImage.otsuAdaptiveThreshold(400, 400, 0, 0, 0.1).image;\n  skew = binarizedImage.findSkew().angle;\n  if (Math.abs(skew) < 0.15) {\n    skew = 0;\n  }\n  if (skew) {\n    return image.rotate(skew);\n  } else {\n    return new dv.Image(image);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-fv/node_modules/fv/lib/filters/filter_background.js":"// Generated by CoffeeScript 1.10.0\nmodule.exports = function(image, fontWidth, fontHeight) {\n  var backgroundMask, foreground;\n  backgroundMask = image.toGray().close(fontWidth, fontHeight).convolve(fontWidth * 1.33, fontHeight * 1.33).invert();\n  backgroundMask = backgroundMask.add(backgroundMask);\n  foreground = image.toColor().add(backgroundMask.toColor());\n  return foreground;\n};\n","/home/travis/build/npmtest/node-npmtest-fv/node_modules/fv/lib/filters/remove_red.js":"// Generated by CoffeeScript 1.10.0\nvar filterBackground;\n\nfilterBackground = require('./filter_background');\n\nmodule.exports = function(image) {\n  var cyan, desaturatedMask, foreground, formMask, hsv, nearInkMask, red, redMask;\n  hsv = filterBackground(image, 25, 35).toHSV();\n  nearInkMask = hsv.inRange(0, 0, 0, 255, 10, 0.9 * 255).dilate(9, 11).erode(11, 11).dilate(11, 11).toGray();\n  desaturatedMask = hsv.inRange(0, 0, 0, 239, 0.3 * 255, 0.9 * 255);\n  desaturatedMask = desaturatedMask.toGray().convolve(2, 2).invert().subtract(nearInkMask);\n  red = image.toGray(1, 0, 0);\n  cyan = image.toGray(0, 0.5, 0.5);\n  redMask = red.subtract(cyan).convolve(1, 1);\n  formMask = redMask.add(redMask).subtract(desaturatedMask);\n  foreground = image.toGray().add(formMask);\n  return foreground;\n};\n"}